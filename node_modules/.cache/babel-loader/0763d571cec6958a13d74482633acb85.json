{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/sgannu/projects/sgannu.github.io/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/Users/sgannu/projects/sgannu.github.io/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/sgannu/projects/sgannu.github.io/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar utils_1 = require(\"./utils\");\n/**\n * Calculate branches paths of the graph.\n *\n * It follows the Command pattern:\n * => a class with a single `execute()` public method.\n *\n * Main benefit is we can split computation in smaller steps without\n * passing around parameters (we can rely on private data).\n */\n\n\nvar BranchesPathsCalculator =\n/*#__PURE__*/\nfunction () {\n  function BranchesPathsCalculator(commits, branches, commitSpacing, isGraphVertical, isGraphReverse, createDeletedBranch) {\n    _classCallCheck(this, BranchesPathsCalculator);\n\n    this.branchesPaths = new Map();\n    this.commits = commits;\n    this.branches = branches;\n    this.commitSpacing = commitSpacing;\n    this.isGraphVertical = isGraphVertical;\n    this.isGraphReverse = isGraphReverse;\n    this.createDeletedBranch = createDeletedBranch;\n  }\n  /**\n   * Compute branches paths for graph.\n   */\n\n\n  _createClass(BranchesPathsCalculator, [{\n    key: \"execute\",\n    value: function execute() {\n      this.fromCommits();\n      this.withMergeCommits();\n      return this.smoothBranchesPaths();\n    }\n    /**\n     * Initialize branches paths from calculator's commits.\n     */\n\n  }, {\n    key: \"fromCommits\",\n    value: function fromCommits() {\n      var _this = this;\n\n      this.commits.forEach(function (commit) {\n        var branch = _this.branches.get(commit.branchToDisplay);\n\n        if (!branch) {\n          // NB: may not work properly if there are many deleted branches.\n          branch = _this.getDeletedBranchInPath() || _this.createDeletedBranch();\n        }\n\n        var path = [];\n\n        var existingBranchPath = _this.branchesPaths.get(branch);\n\n        var firstParentCommit = _this.commits.find(function (_ref) {\n          var hash = _ref.hash;\n          return hash === commit.parents[0];\n        });\n\n        if (existingBranchPath) {\n          path.push.apply(path, _toConsumableArray(existingBranchPath));\n        } else if (firstParentCommit) {\n          // Make branch path starts from parent branch (parent commit).\n          path.push({\n            x: firstParentCommit.x,\n            y: firstParentCommit.y\n          });\n        }\n\n        path.push({\n          x: commit.x,\n          y: commit.y\n        });\n\n        _this.branchesPaths.set(branch, path);\n      });\n    }\n    /**\n     * Insert merge commits points into `branchesPaths`.\n     *\n     * @example\n     *     // Before\n     *     [\n     *       { x: 0, y: 640 },\n     *       { x: 50, y: 560 }\n     *     ]\n     *\n     *     // After\n     *     [\n     *       { x: 0, y: 640 },\n     *       { x: 50, y: 560 },\n     *       { x: 50, y: 560, mergeCommit: true }\n     *     ]\n     */\n\n  }, {\n    key: \"withMergeCommits\",\n    value: function withMergeCommits() {\n      var _this2 = this;\n\n      var mergeCommits = this.commits.filter(function (_ref2) {\n        var parents = _ref2.parents;\n        return parents.length > 1;\n      });\n      mergeCommits.forEach(function (mergeCommit) {\n        var parentOnOriginBranch = _this2.commits.find(function (_ref3) {\n          var hash = _ref3.hash;\n          return hash === mergeCommit.parents[1];\n        });\n\n        if (!parentOnOriginBranch) return;\n        var originBranchName = parentOnOriginBranch.branches ? parentOnOriginBranch.branches[0] : \"\";\n\n        var branch = _this2.branches.get(originBranchName);\n\n        if (!branch) {\n          branch = _this2.getDeletedBranchInPath();\n\n          if (!branch) {\n            // Still no branch? That's strange, we shouldn't set anything.\n            return;\n          }\n        }\n\n        var lastPoints = _toConsumableArray(_this2.branchesPaths.get(branch) || []);\n\n        _this2.branchesPaths.set(branch, [].concat(_toConsumableArray(lastPoints), [{\n          x: mergeCommit.x,\n          y: mergeCommit.y,\n          mergeCommit: true\n        }]));\n      });\n    }\n    /**\n     * Retrieve deleted branch from calculator's branches paths.\n     */\n\n  }, {\n    key: \"getDeletedBranchInPath\",\n    value: function getDeletedBranchInPath() {\n      return Array.from(this.branchesPaths.keys()).find(function (branch) {\n        return branch.isDeleted();\n      });\n    }\n    /**\n     * Smooth all paths by putting points on each row.\n     */\n\n  }, {\n    key: \"smoothBranchesPaths\",\n    value: function smoothBranchesPaths() {\n      var _this3 = this;\n\n      var branchesPaths = new Map();\n      this.branchesPaths.forEach(function (points, branch) {\n        if (points.length <= 1) {\n          branchesPaths.set(branch, [points]);\n          return;\n        } // Cut path on each merge commits\n        // Coordinate[] -> Coordinate[][]\n\n\n        if (_this3.isGraphVertical) {\n          points = points.sort(function (a, b) {\n            return a.y > b.y ? -1 : 1;\n          });\n        } else {\n          points = points.sort(function (a, b) {\n            return a.x > b.x ? 1 : -1;\n          });\n        }\n\n        if (_this3.isGraphReverse) {\n          points = points.reverse();\n        }\n\n        var paths = points.reduce(function (mem, point, i) {\n          if (point.mergeCommit) {\n            mem[mem.length - 1].push(utils_1.pick(point, [\"x\", \"y\"]));\n            var j = i - 1;\n            var previousPoint = points[j]; // Find the last point which is not a merge\n\n            while (j >= 0 && previousPoint.mergeCommit) {\n              j--;\n              previousPoint = points[j];\n            } // Start a new array with this point\n\n\n            if (j >= 0) {\n              mem.push([previousPoint]);\n            }\n          } else {\n            mem[mem.length - 1].push(point);\n          }\n\n          return mem;\n        }, [[]]);\n\n        if (_this3.isGraphReverse) {\n          paths.forEach(function (path) {\n            return path.reverse();\n          });\n        } // Add intermediate points on each sub paths\n\n\n        if (_this3.isGraphVertical) {\n          paths.forEach(function (subPath) {\n            if (subPath.length <= 1) return;\n            var firstPoint = subPath[0];\n            var lastPoint = subPath[subPath.length - 1];\n            var column = subPath[1].x;\n            var branchSize = Math.round(Math.abs(firstPoint.y - lastPoint.y) / _this3.commitSpacing) - 1;\n            var branchPoints = branchSize > 0 ? new Array(branchSize).fill(0).map(function (_, i) {\n              return {\n                x: column,\n                y: subPath[0].y - _this3.commitSpacing * (i + 1)\n              };\n            }) : [];\n            var lastSubPaths = branchesPaths.get(branch) || [];\n            branchesPaths.set(branch, [].concat(_toConsumableArray(lastSubPaths), [[firstPoint].concat(_toConsumableArray(branchPoints), [lastPoint])]));\n          });\n        } else {\n          paths.forEach(function (subPath) {\n            if (subPath.length <= 1) return;\n            var firstPoint = subPath[0];\n            var lastPoint = subPath[subPath.length - 1];\n            var column = subPath[1].y;\n            var branchSize = Math.round(Math.abs(firstPoint.x - lastPoint.x) / _this3.commitSpacing) - 1;\n            var branchPoints = branchSize > 0 ? new Array(branchSize).fill(0).map(function (_, i) {\n              return {\n                y: column,\n                x: subPath[0].x + _this3.commitSpacing * (i + 1)\n              };\n            }) : [];\n            var lastSubPaths = branchesPaths.get(branch) || [];\n            branchesPaths.set(branch, [].concat(_toConsumableArray(lastSubPaths), [[firstPoint].concat(_toConsumableArray(branchPoints), [lastPoint])]));\n          });\n        }\n      });\n      return branchesPaths;\n    }\n  }]);\n\n  return BranchesPathsCalculator;\n}();\n\nexports.BranchesPathsCalculator = BranchesPathsCalculator;\n/**\n * Return a string ready to use in `svg.path.d` from coordinates\n *\n * @param coordinates Collection of coordinates\n */\n\nfunction toSvgPath(coordinates, isBezier, isVertical) {\n  return coordinates.map(function (path) {\n    return \"M\" + path.map(function (_ref4, i, points) {\n      var x = _ref4.x,\n          y = _ref4.y;\n\n      if (isBezier && points.length > 1 && (i === 1 || i === points.length - 1)) {\n        var previous = points[i - 1];\n\n        if (isVertical) {\n          var middleY = (previous.y + y) / 2;\n          return \"C \".concat(previous.x, \" \").concat(middleY, \" \").concat(x, \" \").concat(middleY, \" \").concat(x, \" \").concat(y);\n        } else {\n          var middleX = (previous.x + x) / 2;\n          return \"C \".concat(middleX, \" \").concat(previous.y, \" \").concat(middleX, \" \").concat(y, \" \").concat(x, \" \").concat(y);\n        }\n      }\n\n      return \"L \".concat(x, \" \").concat(y);\n    }).join(\" \").slice(1);\n  }).join(\" \");\n}\n\nexports.toSvgPath = toSvgPath;","map":{"version":3,"sources":["../src/branches-paths.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"./utils\");\n/**\n * Calculate branches paths of the graph.\n *\n * It follows the Command pattern:\n * => a class with a single `execute()` public method.\n *\n * Main benefit is we can split computation in smaller steps without\n * passing around parameters (we can rely on private data).\n */\nclass BranchesPathsCalculator {\n    constructor(commits, branches, commitSpacing, isGraphVertical, isGraphReverse, createDeletedBranch) {\n        this.branchesPaths = new Map();\n        this.commits = commits;\n        this.branches = branches;\n        this.commitSpacing = commitSpacing;\n        this.isGraphVertical = isGraphVertical;\n        this.isGraphReverse = isGraphReverse;\n        this.createDeletedBranch = createDeletedBranch;\n    }\n    /**\n     * Compute branches paths for graph.\n     */\n    execute() {\n        this.fromCommits();\n        this.withMergeCommits();\n        return this.smoothBranchesPaths();\n    }\n    /**\n     * Initialize branches paths from calculator's commits.\n     */\n    fromCommits() {\n        this.commits.forEach((commit) => {\n            let branch = this.branches.get(commit.branchToDisplay);\n            if (!branch) {\n                // NB: may not work properly if there are many deleted branches.\n                branch = this.getDeletedBranchInPath() || this.createDeletedBranch();\n            }\n            const path = [];\n            const existingBranchPath = this.branchesPaths.get(branch);\n            const firstParentCommit = this.commits.find(({ hash }) => hash === commit.parents[0]);\n            if (existingBranchPath) {\n                path.push(...existingBranchPath);\n            }\n            else if (firstParentCommit) {\n                // Make branch path starts from parent branch (parent commit).\n                path.push({ x: firstParentCommit.x, y: firstParentCommit.y });\n            }\n            path.push({ x: commit.x, y: commit.y });\n            this.branchesPaths.set(branch, path);\n        });\n    }\n    /**\n     * Insert merge commits points into `branchesPaths`.\n     *\n     * @example\n     *     // Before\n     *     [\n     *       { x: 0, y: 640 },\n     *       { x: 50, y: 560 }\n     *     ]\n     *\n     *     // After\n     *     [\n     *       { x: 0, y: 640 },\n     *       { x: 50, y: 560 },\n     *       { x: 50, y: 560, mergeCommit: true }\n     *     ]\n     */\n    withMergeCommits() {\n        const mergeCommits = this.commits.filter(({ parents }) => parents.length > 1);\n        mergeCommits.forEach((mergeCommit) => {\n            const parentOnOriginBranch = this.commits.find(({ hash }) => {\n                return hash === mergeCommit.parents[1];\n            });\n            if (!parentOnOriginBranch)\n                return;\n            const originBranchName = parentOnOriginBranch.branches\n                ? parentOnOriginBranch.branches[0]\n                : \"\";\n            let branch = this.branches.get(originBranchName);\n            if (!branch) {\n                branch = this.getDeletedBranchInPath();\n                if (!branch) {\n                    // Still no branch? That's strange, we shouldn't set anything.\n                    return;\n                }\n            }\n            const lastPoints = [...(this.branchesPaths.get(branch) || [])];\n            this.branchesPaths.set(branch, [\n                ...lastPoints,\n                { x: mergeCommit.x, y: mergeCommit.y, mergeCommit: true },\n            ]);\n        });\n    }\n    /**\n     * Retrieve deleted branch from calculator's branches paths.\n     */\n    getDeletedBranchInPath() {\n        return Array.from(this.branchesPaths.keys()).find((branch) => branch.isDeleted());\n    }\n    /**\n     * Smooth all paths by putting points on each row.\n     */\n    smoothBranchesPaths() {\n        const branchesPaths = new Map();\n        this.branchesPaths.forEach((points, branch) => {\n            if (points.length <= 1) {\n                branchesPaths.set(branch, [points]);\n                return;\n            }\n            // Cut path on each merge commits\n            // Coordinate[] -> Coordinate[][]\n            if (this.isGraphVertical) {\n                points = points.sort((a, b) => (a.y > b.y ? -1 : 1));\n            }\n            else {\n                points = points.sort((a, b) => (a.x > b.x ? 1 : -1));\n            }\n            if (this.isGraphReverse) {\n                points = points.reverse();\n            }\n            const paths = points.reduce((mem, point, i) => {\n                if (point.mergeCommit) {\n                    mem[mem.length - 1].push(utils_1.pick(point, [\"x\", \"y\"]));\n                    let j = i - 1;\n                    let previousPoint = points[j];\n                    // Find the last point which is not a merge\n                    while (j >= 0 && previousPoint.mergeCommit) {\n                        j--;\n                        previousPoint = points[j];\n                    }\n                    // Start a new array with this point\n                    if (j >= 0) {\n                        mem.push([previousPoint]);\n                    }\n                }\n                else {\n                    mem[mem.length - 1].push(point);\n                }\n                return mem;\n            }, [[]]);\n            if (this.isGraphReverse) {\n                paths.forEach((path) => path.reverse());\n            }\n            // Add intermediate points on each sub paths\n            if (this.isGraphVertical) {\n                paths.forEach((subPath) => {\n                    if (subPath.length <= 1)\n                        return;\n                    const firstPoint = subPath[0];\n                    const lastPoint = subPath[subPath.length - 1];\n                    const column = subPath[1].x;\n                    const branchSize = Math.round(Math.abs(firstPoint.y - lastPoint.y) / this.commitSpacing) - 1;\n                    const branchPoints = branchSize > 0\n                        ? new Array(branchSize).fill(0).map((_, i) => ({\n                            x: column,\n                            y: subPath[0].y - this.commitSpacing * (i + 1),\n                        }))\n                        : [];\n                    const lastSubPaths = branchesPaths.get(branch) || [];\n                    branchesPaths.set(branch, [\n                        ...lastSubPaths,\n                        [firstPoint, ...branchPoints, lastPoint],\n                    ]);\n                });\n            }\n            else {\n                paths.forEach((subPath) => {\n                    if (subPath.length <= 1)\n                        return;\n                    const firstPoint = subPath[0];\n                    const lastPoint = subPath[subPath.length - 1];\n                    const column = subPath[1].y;\n                    const branchSize = Math.round(Math.abs(firstPoint.x - lastPoint.x) / this.commitSpacing) - 1;\n                    const branchPoints = branchSize > 0\n                        ? new Array(branchSize).fill(0).map((_, i) => ({\n                            y: column,\n                            x: subPath[0].x + this.commitSpacing * (i + 1),\n                        }))\n                        : [];\n                    const lastSubPaths = branchesPaths.get(branch) || [];\n                    branchesPaths.set(branch, [\n                        ...lastSubPaths,\n                        [firstPoint, ...branchPoints, lastPoint],\n                    ]);\n                });\n            }\n        });\n        return branchesPaths;\n    }\n}\nexports.BranchesPathsCalculator = BranchesPathsCalculator;\n/**\n * Return a string ready to use in `svg.path.d` from coordinates\n *\n * @param coordinates Collection of coordinates\n */\nfunction toSvgPath(coordinates, isBezier, isVertical) {\n    return coordinates\n        .map((path) => \"M\" +\n        path\n            .map(({ x, y }, i, points) => {\n            if (isBezier &&\n                points.length > 1 &&\n                (i === 1 || i === points.length - 1)) {\n                const previous = points[i - 1];\n                if (isVertical) {\n                    const middleY = (previous.y + y) / 2;\n                    return `C ${previous.x} ${middleY} ${x} ${middleY} ${x} ${y}`;\n                }\n                else {\n                    const middleX = (previous.x + x) / 2;\n                    return `C ${middleX} ${previous.y} ${middleX} ${y} ${x} ${y}`;\n                }\n            }\n            return `L ${x} ${y}`;\n        })\n            .join(\" \")\n            .slice(1))\n        .join(\" \");\n}\nexports.toSvgPath = toSvgPath;\n//# sourceMappingURL=branches-paths.js.map"]},"metadata":{},"sourceType":"script"}