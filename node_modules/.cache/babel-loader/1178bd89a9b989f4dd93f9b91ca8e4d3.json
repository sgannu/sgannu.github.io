{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"./utils\");\n/**\n * Calculate branches paths of the graph.\n *\n * It follows the Command pattern:\n * => a class with a single `execute()` public method.\n *\n * Main benefit is we can split computation in smaller steps without\n * passing around parameters (we can rely on private data).\n */\n\n\nclass BranchesPathsCalculator {\n  constructor(commits, branches, commitSpacing, isGraphVertical, isGraphReverse, createDeletedBranch) {\n    this.branchesPaths = new Map();\n    this.commits = commits;\n    this.branches = branches;\n    this.commitSpacing = commitSpacing;\n    this.isGraphVertical = isGraphVertical;\n    this.isGraphReverse = isGraphReverse;\n    this.createDeletedBranch = createDeletedBranch;\n  }\n  /**\n   * Compute branches paths for graph.\n   */\n\n\n  execute() {\n    this.fromCommits();\n    this.withMergeCommits();\n    return this.smoothBranchesPaths();\n  }\n  /**\n   * Initialize branches paths from calculator's commits.\n   */\n\n\n  fromCommits() {\n    this.commits.forEach(commit => {\n      let branch = this.branches.get(commit.branchToDisplay);\n\n      if (!branch) {\n        // NB: may not work properly if there are many deleted branches.\n        branch = this.getDeletedBranchInPath() || this.createDeletedBranch();\n      }\n\n      const path = [];\n      const existingBranchPath = this.branchesPaths.get(branch);\n      const firstParentCommit = this.commits.find(({\n        hash\n      }) => hash === commit.parents[0]);\n\n      if (existingBranchPath) {\n        path.push(...existingBranchPath);\n      } else if (firstParentCommit) {\n        // Make branch path starts from parent branch (parent commit).\n        path.push({\n          x: firstParentCommit.x,\n          y: firstParentCommit.y\n        });\n      }\n\n      path.push({\n        x: commit.x,\n        y: commit.y\n      });\n      this.branchesPaths.set(branch, path);\n    });\n  }\n  /**\n   * Insert merge commits points into `branchesPaths`.\n   *\n   * @example\n   *     // Before\n   *     [\n   *       { x: 0, y: 640 },\n   *       { x: 50, y: 560 }\n   *     ]\n   *\n   *     // After\n   *     [\n   *       { x: 0, y: 640 },\n   *       { x: 50, y: 560 },\n   *       { x: 50, y: 560, mergeCommit: true }\n   *     ]\n   */\n\n\n  withMergeCommits() {\n    const mergeCommits = this.commits.filter(({\n      parents\n    }) => parents.length > 1);\n    mergeCommits.forEach(mergeCommit => {\n      const parentOnOriginBranch = this.commits.find(({\n        hash\n      }) => {\n        return hash === mergeCommit.parents[1];\n      });\n      if (!parentOnOriginBranch) return;\n      const originBranchName = parentOnOriginBranch.branches ? parentOnOriginBranch.branches[0] : \"\";\n      let branch = this.branches.get(originBranchName);\n\n      if (!branch) {\n        branch = this.getDeletedBranchInPath();\n\n        if (!branch) {\n          // Still no branch? That's strange, we shouldn't set anything.\n          return;\n        }\n      }\n\n      const lastPoints = [...(this.branchesPaths.get(branch) || [])];\n      this.branchesPaths.set(branch, [...lastPoints, {\n        x: mergeCommit.x,\n        y: mergeCommit.y,\n        mergeCommit: true\n      }]);\n    });\n  }\n  /**\n   * Retrieve deleted branch from calculator's branches paths.\n   */\n\n\n  getDeletedBranchInPath() {\n    return Array.from(this.branchesPaths.keys()).find(branch => branch.isDeleted());\n  }\n  /**\n   * Smooth all paths by putting points on each row.\n   */\n\n\n  smoothBranchesPaths() {\n    const branchesPaths = new Map();\n    this.branchesPaths.forEach((points, branch) => {\n      if (points.length <= 1) {\n        branchesPaths.set(branch, [points]);\n        return;\n      } // Cut path on each merge commits\n      // Coordinate[] -> Coordinate[][]\n\n\n      if (this.isGraphVertical) {\n        points = points.sort((a, b) => a.y > b.y ? -1 : 1);\n      } else {\n        points = points.sort((a, b) => a.x > b.x ? 1 : -1);\n      }\n\n      if (this.isGraphReverse) {\n        points = points.reverse();\n      }\n\n      const paths = points.reduce((mem, point, i) => {\n        if (point.mergeCommit) {\n          mem[mem.length - 1].push(utils_1.pick(point, [\"x\", \"y\"]));\n          let j = i - 1;\n          let previousPoint = points[j]; // Find the last point which is not a merge\n\n          while (j >= 0 && previousPoint.mergeCommit) {\n            j--;\n            previousPoint = points[j];\n          } // Start a new array with this point\n\n\n          if (j >= 0) {\n            mem.push([previousPoint]);\n          }\n        } else {\n          mem[mem.length - 1].push(point);\n        }\n\n        return mem;\n      }, [[]]);\n\n      if (this.isGraphReverse) {\n        paths.forEach(path => path.reverse());\n      } // Add intermediate points on each sub paths\n\n\n      if (this.isGraphVertical) {\n        paths.forEach(subPath => {\n          if (subPath.length <= 1) return;\n          const firstPoint = subPath[0];\n          const lastPoint = subPath[subPath.length - 1];\n          const column = subPath[1].x;\n          const branchSize = Math.round(Math.abs(firstPoint.y - lastPoint.y) / this.commitSpacing) - 1;\n          const branchPoints = branchSize > 0 ? new Array(branchSize).fill(0).map((_, i) => ({\n            x: column,\n            y: subPath[0].y - this.commitSpacing * (i + 1)\n          })) : [];\n          const lastSubPaths = branchesPaths.get(branch) || [];\n          branchesPaths.set(branch, [...lastSubPaths, [firstPoint, ...branchPoints, lastPoint]]);\n        });\n      } else {\n        paths.forEach(subPath => {\n          if (subPath.length <= 1) return;\n          const firstPoint = subPath[0];\n          const lastPoint = subPath[subPath.length - 1];\n          const column = subPath[1].y;\n          const branchSize = Math.round(Math.abs(firstPoint.x - lastPoint.x) / this.commitSpacing) - 1;\n          const branchPoints = branchSize > 0 ? new Array(branchSize).fill(0).map((_, i) => ({\n            y: column,\n            x: subPath[0].x + this.commitSpacing * (i + 1)\n          })) : [];\n          const lastSubPaths = branchesPaths.get(branch) || [];\n          branchesPaths.set(branch, [...lastSubPaths, [firstPoint, ...branchPoints, lastPoint]]);\n        });\n      }\n    });\n    return branchesPaths;\n  }\n\n}\n\nexports.BranchesPathsCalculator = BranchesPathsCalculator;\n/**\n * Return a string ready to use in `svg.path.d` from coordinates\n *\n * @param coordinates Collection of coordinates\n */\n\nfunction toSvgPath(coordinates, isBezier, isVertical) {\n  return coordinates.map(path => \"M\" + path.map(({\n    x,\n    y\n  }, i, points) => {\n    if (isBezier && points.length > 1 && (i === 1 || i === points.length - 1)) {\n      const previous = points[i - 1];\n\n      if (isVertical) {\n        const middleY = (previous.y + y) / 2;\n        return `C ${previous.x} ${middleY} ${x} ${middleY} ${x} ${y}`;\n      } else {\n        const middleX = (previous.x + x) / 2;\n        return `C ${middleX} ${previous.y} ${middleX} ${y} ${x} ${y}`;\n      }\n    }\n\n    return `L ${x} ${y}`;\n  }).join(\" \").slice(1)).join(\" \");\n}\n\nexports.toSvgPath = toSvgPath;","map":{"version":3,"sources":["../src/branches-paths.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"./utils\");\n/**\n * Calculate branches paths of the graph.\n *\n * It follows the Command pattern:\n * => a class with a single `execute()` public method.\n *\n * Main benefit is we can split computation in smaller steps without\n * passing around parameters (we can rely on private data).\n */\nclass BranchesPathsCalculator {\n    constructor(commits, branches, commitSpacing, isGraphVertical, isGraphReverse, createDeletedBranch) {\n        this.branchesPaths = new Map();\n        this.commits = commits;\n        this.branches = branches;\n        this.commitSpacing = commitSpacing;\n        this.isGraphVertical = isGraphVertical;\n        this.isGraphReverse = isGraphReverse;\n        this.createDeletedBranch = createDeletedBranch;\n    }\n    /**\n     * Compute branches paths for graph.\n     */\n    execute() {\n        this.fromCommits();\n        this.withMergeCommits();\n        return this.smoothBranchesPaths();\n    }\n    /**\n     * Initialize branches paths from calculator's commits.\n     */\n    fromCommits() {\n        this.commits.forEach((commit) => {\n            let branch = this.branches.get(commit.branchToDisplay);\n            if (!branch) {\n                // NB: may not work properly if there are many deleted branches.\n                branch = this.getDeletedBranchInPath() || this.createDeletedBranch();\n            }\n            const path = [];\n            const existingBranchPath = this.branchesPaths.get(branch);\n            const firstParentCommit = this.commits.find(({ hash }) => hash === commit.parents[0]);\n            if (existingBranchPath) {\n                path.push(...existingBranchPath);\n            }\n            else if (firstParentCommit) {\n                // Make branch path starts from parent branch (parent commit).\n                path.push({ x: firstParentCommit.x, y: firstParentCommit.y });\n            }\n            path.push({ x: commit.x, y: commit.y });\n            this.branchesPaths.set(branch, path);\n        });\n    }\n    /**\n     * Insert merge commits points into `branchesPaths`.\n     *\n     * @example\n     *     // Before\n     *     [\n     *       { x: 0, y: 640 },\n     *       { x: 50, y: 560 }\n     *     ]\n     *\n     *     // After\n     *     [\n     *       { x: 0, y: 640 },\n     *       { x: 50, y: 560 },\n     *       { x: 50, y: 560, mergeCommit: true }\n     *     ]\n     */\n    withMergeCommits() {\n        const mergeCommits = this.commits.filter(({ parents }) => parents.length > 1);\n        mergeCommits.forEach((mergeCommit) => {\n            const parentOnOriginBranch = this.commits.find(({ hash }) => {\n                return hash === mergeCommit.parents[1];\n            });\n            if (!parentOnOriginBranch)\n                return;\n            const originBranchName = parentOnOriginBranch.branches\n                ? parentOnOriginBranch.branches[0]\n                : \"\";\n            let branch = this.branches.get(originBranchName);\n            if (!branch) {\n                branch = this.getDeletedBranchInPath();\n                if (!branch) {\n                    // Still no branch? That's strange, we shouldn't set anything.\n                    return;\n                }\n            }\n            const lastPoints = [...(this.branchesPaths.get(branch) || [])];\n            this.branchesPaths.set(branch, [\n                ...lastPoints,\n                { x: mergeCommit.x, y: mergeCommit.y, mergeCommit: true },\n            ]);\n        });\n    }\n    /**\n     * Retrieve deleted branch from calculator's branches paths.\n     */\n    getDeletedBranchInPath() {\n        return Array.from(this.branchesPaths.keys()).find((branch) => branch.isDeleted());\n    }\n    /**\n     * Smooth all paths by putting points on each row.\n     */\n    smoothBranchesPaths() {\n        const branchesPaths = new Map();\n        this.branchesPaths.forEach((points, branch) => {\n            if (points.length <= 1) {\n                branchesPaths.set(branch, [points]);\n                return;\n            }\n            // Cut path on each merge commits\n            // Coordinate[] -> Coordinate[][]\n            if (this.isGraphVertical) {\n                points = points.sort((a, b) => (a.y > b.y ? -1 : 1));\n            }\n            else {\n                points = points.sort((a, b) => (a.x > b.x ? 1 : -1));\n            }\n            if (this.isGraphReverse) {\n                points = points.reverse();\n            }\n            const paths = points.reduce((mem, point, i) => {\n                if (point.mergeCommit) {\n                    mem[mem.length - 1].push(utils_1.pick(point, [\"x\", \"y\"]));\n                    let j = i - 1;\n                    let previousPoint = points[j];\n                    // Find the last point which is not a merge\n                    while (j >= 0 && previousPoint.mergeCommit) {\n                        j--;\n                        previousPoint = points[j];\n                    }\n                    // Start a new array with this point\n                    if (j >= 0) {\n                        mem.push([previousPoint]);\n                    }\n                }\n                else {\n                    mem[mem.length - 1].push(point);\n                }\n                return mem;\n            }, [[]]);\n            if (this.isGraphReverse) {\n                paths.forEach((path) => path.reverse());\n            }\n            // Add intermediate points on each sub paths\n            if (this.isGraphVertical) {\n                paths.forEach((subPath) => {\n                    if (subPath.length <= 1)\n                        return;\n                    const firstPoint = subPath[0];\n                    const lastPoint = subPath[subPath.length - 1];\n                    const column = subPath[1].x;\n                    const branchSize = Math.round(Math.abs(firstPoint.y - lastPoint.y) / this.commitSpacing) - 1;\n                    const branchPoints = branchSize > 0\n                        ? new Array(branchSize).fill(0).map((_, i) => ({\n                            x: column,\n                            y: subPath[0].y - this.commitSpacing * (i + 1),\n                        }))\n                        : [];\n                    const lastSubPaths = branchesPaths.get(branch) || [];\n                    branchesPaths.set(branch, [\n                        ...lastSubPaths,\n                        [firstPoint, ...branchPoints, lastPoint],\n                    ]);\n                });\n            }\n            else {\n                paths.forEach((subPath) => {\n                    if (subPath.length <= 1)\n                        return;\n                    const firstPoint = subPath[0];\n                    const lastPoint = subPath[subPath.length - 1];\n                    const column = subPath[1].y;\n                    const branchSize = Math.round(Math.abs(firstPoint.x - lastPoint.x) / this.commitSpacing) - 1;\n                    const branchPoints = branchSize > 0\n                        ? new Array(branchSize).fill(0).map((_, i) => ({\n                            y: column,\n                            x: subPath[0].x + this.commitSpacing * (i + 1),\n                        }))\n                        : [];\n                    const lastSubPaths = branchesPaths.get(branch) || [];\n                    branchesPaths.set(branch, [\n                        ...lastSubPaths,\n                        [firstPoint, ...branchPoints, lastPoint],\n                    ]);\n                });\n            }\n        });\n        return branchesPaths;\n    }\n}\nexports.BranchesPathsCalculator = BranchesPathsCalculator;\n/**\n * Return a string ready to use in `svg.path.d` from coordinates\n *\n * @param coordinates Collection of coordinates\n */\nfunction toSvgPath(coordinates, isBezier, isVertical) {\n    return coordinates\n        .map((path) => \"M\" +\n        path\n            .map(({ x, y }, i, points) => {\n            if (isBezier &&\n                points.length > 1 &&\n                (i === 1 || i === points.length - 1)) {\n                const previous = points[i - 1];\n                if (isVertical) {\n                    const middleY = (previous.y + y) / 2;\n                    return `C ${previous.x} ${middleY} ${x} ${middleY} ${x} ${y}`;\n                }\n                else {\n                    const middleX = (previous.x + x) / 2;\n                    return `C ${middleX} ${previous.y} ${middleX} ${y} ${x} ${y}`;\n                }\n            }\n            return `L ${x} ${y}`;\n        })\n            .join(\" \")\n            .slice(1))\n        .join(\" \");\n}\nexports.toSvgPath = toSvgPath;\n//# sourceMappingURL=branches-paths.js.map"]},"metadata":{},"sourceType":"script"}